{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\npotentiometerV2_h = PotentiometerV2(brain.three_wire_port.h)\npotentiometerV2_a = PotentiometerV2(brain.three_wire_port.a)\nmotor_2 = Motor(Ports.PORT2, False)\nbicep_motor_a = Motor(Ports.PORT1, False)\nbicep_motor_b = Motor(Ports.PORT6, True)\nbicep = MotorGroup(bicep_motor_a, bicep_motor_b)\nservo_c = Servo(brain.three_wire_port.c)\ndistance_7 = Distance(Ports.PORT7)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode EXP Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\n# Bicep, Forearm Length\nlength1 = 12\nlength2 = 6\n\n# Convert pot degrees to degrees relative to the bicep/forearm start\noffset1 = 86\noffset2  = 145\n\n# takes two input angles and check for angle and position validity\ndef safetycheck(angle1, angle2):\n        angle1rad = math.radians(angle1)\n        angle2rad = math.radians(angle2)\n        anglealpha = angle1rad-angle2rad\n\n        x1 = length1 * math.cos(angle1rad)\n        y1 = length1 * math.sin(angle1rad)\n        x2 = length2 * math.cos(anglealpha)\n        y2 = length2 * math.sin(anglealpha)\n        \n        finalX = x1 + x2\n        finalY = y1 + y2\n        \n        # print(\"x: \" + str(x1) + \" y: \" + str(y1))\n        print(\"final x: \" + str(finalX) + \" final y: \" + str(finalY))\n        \n        # is the angle valid?\n        if ((angle1 < 0) or (angle1 > 90)):\n            print(\"error: invalid shoulder angle. Only ranges between 0 and 90 are accepted.\")\n            return(-1)\n        elif((angle2 < -91) or (angle2 > 120)):\n            print(\"error: invalid forearm angle. Only ranges between -40 and 120 are accepted\")\n            return(-1)\n\n        # does the angle result in valid \"Y\" values    \n        elif (y1 < -1):\n            print(x1,y1)\n            print(\"error: angle results in invalid elbow position\")\n            return(-1)\n        elif((y1+y2) < -1):\n            print(\"error: angle results in invalid forearm position\")\n            return(-1)\n\n        # safetycheck(a1,a2) must equal 1 for any movement to occur    \n        else:\n            print(\"good to go !\")\n            return(1)\n\n\ndef  movearms(angle1, angle2):\n        # reverse angle: forearm angle increases towards the table (overhand)\n        angle2 = -angle2\n        \n        # slow enough for predictable outcomes or fall apart\n        bicep.set_velocity(10,PERCENT)\n        motor_2.set_velocity(10,PERCENT)\n\n        #move shoulder/bicep into position\n        # above desired angle, move down bicep\n        if (potentiometerV2_h.angle(DEGREES) > (angle1+offset1)):\n            while True:\n                bicep.spin(FORWARD)\n                if (potentiometerV2_h.angle(DEGREES) < (angle1+offset1)):\n                    bicep.stop()\n                    break\n\n        # below desired angle, move up bicep\n        elif(potentiometerV2_h.angle(DEGREES) < (angle1+offset1)):\n            while True:\n                bicep.spin(REVERSE)\n                if (potentiometerV2_h.angle(DEGREES) > (angle1+offset1)):\n                    bicep.stop()\n                    bicep.stop()\n                    break\n            \n        # above desired angle, move down forearm\n        if (potentiometerV2_a.angle(DEGREES) > (angle2+offset2)):\n            print(\"moving down\")\n            while True:\n                motor_2.spin(FORWARD)\n                if(potentiometerV2_a.angle(DEGREES) < (angle2+offset2)):\n                    motor_2.stop()\n                    break\n\n        # below desired angle, move up forearm\n        elif(potentiometerV2_a.angle(DEGREES) < (angle2+offset2)):\n            print(\"moving up\")\n            while True:\n                motor_2.spin(REVERSE)\n                if(potentiometerV2_a.angle(DEGREES) > (angle2+offset2)):\n                    motor_2.stop()\n                    break\n       \n        print(\"move done\")\n        \n# functions which sets claw to max and min opening states\ndef clawgrab():\n    servo_c.set_position(50,DEGREES)\n\ndef clawrelease():\n    servo_c.set_position(-50,DEGREES)\n\n# check that angles are valid, then move arms, then check again\ndef run(a1,a2):\n    if (safetycheck(a1,a2) == 1):\n        movearms(a1,a2)\n        safetycheck(a1,a2)\n\n# find the proper angles to allow the arms to move to the endpoint\ndef inverseKinematics(x, y):    \n    theta2 = math.acos(((math.pow(x,2)) + (math.pow(y,2)) - (math.pow(length1,2)) - (math.pow(length2, 2))) / (2 * length1 * length2))\n    # print(math.degrees(theta2))\n    \n    # tan^-1 (y/x) = alpha, which is going to be added to the rest instead of subtracted due to the overhand design\n    theta1 = math.atan(y / x) + math.asin((length2 * math.sin(theta2)) / math.sqrt((math.pow(x,2)) + (math.pow(y,2))))\n    \n    # print(math.degrees(theta1)) \n    return theta1, theta2\n\nwhile True:\n    # start with open claw\n    clawrelease()\n\n    # distance: from bottom of robot to can +5 inch buffer to allow bot to grab center of can\n    goal_distance = distance_7.object_distance(INCHES) + 5\n\n    # find proper angles\n    # always pick up a can at y = 3.1\n    t1, t2 = inverseKinematics(goal_distance,3.1)\n\n    print(\"Theta1: \" + str(math.degrees(t1)) + \"Theta2: \" + str(math.degrees(t2)))\n\n    # convert kinematics angles into degrees and run bot\n    run(math.degrees(t1), math.degrees(t2))\n\n    # ideally ends at correct endpoint and grabs can\n    clawgrab()\n\n    # position which bot drops can over its axis\n    run(80,-40)\n\n    # drop can\n    clawrelease()\n\nprint(\"object distance: \" + str(distance_7.object_distance(INCHES)))\n\n\n\n\n\n\n","textLanguage":"python","rconfig":[{"port":[8],"name":"potentiometerV2_h","customName":false,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[1],"name":"potentiometerV2_a","customName":false,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[2],"name":"motor_2","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[1,6],"name":"bicep","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[3],"name":"servo_c","customName":false,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22},{"port":[7],"name":"distance_7","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"EXP","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}